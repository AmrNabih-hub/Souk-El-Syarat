import { DataStore } from '@aws-amplify/datastore';
import { User, Vendor, Product, Order } from '@/models';
import {
  AnalyticsEvent,
  SystemMetrics,
  BusinessMetrics,
  RealTimeStats,
} from '@/models'; // Assuming models are generated by Amplify

export type { BusinessMetrics, RealTimeStats } from '@/models';

export class AnalyticsService {
  /**
   * Track analytics event
   */
  static async trackEvent(event: any): Promise<string> {
    const payload = {
      ...event,
      metadata: typeof event.metadata === 'string' ? event.metadata : JSON.stringify(event.metadata || {}),
      timestamp: new Date().toISOString(),
    } as any;
    const newEvent = new AnalyticsEvent(payload);
    const savedEvent = await DataStore.save(newEvent);
    return savedEvent.id;
  }

  /**
   * Track multiple events in batch
   */
  static async trackEvents(
    events: Array<Omit<AnalyticsEvent, 'id' | 'timestamp'>>
  ): Promise<string[]> {
    const savedEventIds = await Promise.all(
      events.map(async (event) => {
        const newEvent = new AnalyticsEvent({
          ...event,
          timestamp: new Date().toISOString(),
        });
        const savedEvent = await DataStore.save(newEvent);
        return savedEvent.id;
      })
    );
    return savedEventIds;
  }

  /**
   * Track system metric
   */
  static async trackMetric(
    type: SystemMetrics['type'],
    metric: string,
    value: number,
    unit: string,
    tags?: Record<string, string>
  ): Promise<string> {
    const newMetric = new SystemMetrics({
      type,
      metric,
      value,
      unit,
      tags: JSON.stringify(tags),
      timestamp: new Date().toISOString(),
    });
    const savedMetric = await DataStore.save(newMetric);
    return savedMetric.id;
  }

  /**
   * Get business metrics with real-time updates
   */
  static subscribeToBusinessMetrics(callback: (metrics: BusinessMetrics) => void): () => void {
    const subscription = DataStore.observe(BusinessMetrics).subscribe(({ element }) => {
      callback(element);
    });

    return () => subscription.unsubscribe();
  }

  /**
   * Get real-time stats with live updates
   */
  static subscribeToRealTimeStats(callback: (stats: RealTimeStats) => void): () => void {
    const subscription = DataStore.observe(RealTimeStats).subscribe(({ element }) => {
      callback(element);
    });

    return () => subscription.unsubscribe();
  }

  /**
   * Update business metrics (should be called periodically)
   */
  static async updateBusinessMetrics(): Promise<void> {
    const [users, vendors, products, orders] = await Promise.all([
      DataStore.query(User),
      DataStore.query(Vendor),
      DataStore.query(Product),
      DataStore.query(Order),
    ]);

    const totalUsers = users.length;
    const totalVendors = vendors.length;
    const totalProducts = products.length;
    const totalOrders = orders.length;

    let totalRevenue = 0;
    let completedOrders = 0;

    orders.forEach((order) => {
      if (order.status === 'completed') {
        completedOrders++;
        totalRevenue += order.total || 0;
      }
    });

    const averageOrderValue = completedOrders > 0 ? totalRevenue / completedOrders : 0;
    const conversionRate = totalUsers > 0 ? (completedOrders / totalUsers) * 100 : 0;

    const metrics = await DataStore.query(BusinessMetrics);
    const currentMetrics = metrics[0];

    if (currentMetrics) {
      await DataStore.save(
        BusinessMetrics.copyOf(currentMetrics, (updated) => {
          updated.totalUsers = totalUsers;
          updated.totalVendors = totalVendors;
          updated.totalProducts = totalProducts;
          updated.totalOrders = totalOrders;
          updated.totalRevenue = totalRevenue;
          updated.completedOrders = completedOrders;
          updated.averageOrderValue = averageOrderValue;
          updated.conversionRate = conversionRate;
        })
      );
    } else {
      await DataStore.save(
        new BusinessMetrics({
          totalUsers,
          totalVendors,
          totalProducts,
          totalOrders,
          totalRevenue,
          completedOrders,
          averageOrderValue,
          conversionRate,
          activeUsers: 0,
          activeVendors: 0,
          activeProducts: 0,
          topCategories: [],
          topVendors: [],
          topProducts: [],
          revenueByPeriod: [],
          userGrowth: [],
        })
      );
    }
  }

  /**
   * Update real-time stats (should be called frequently)
   */
  static async updateRealTimeStats(): Promise<void> {
    const [pendingOrders, processingOrders, recentOrders, recentSignups] = await Promise.all([
      DataStore.query(Order, (c) => c.status('eq', 'pending')),
      DataStore.query(Order, (c) => c.status('eq', 'processing')),
      DataStore.query(Order, (c) => c.sort((s) => s.createdAt('DESCENDING')).limit(10)),
      DataStore.query(User, (c) => c.sort((s) => s.createdAt('DESCENDING')).limit(10)),
    ]);

    const stats = await DataStore.query(RealTimeStats);
    const currentStats = stats[0];

    if (currentStats) {
      await DataStore.save(
        RealTimeStats.copyOf(currentStats, (updated) => {
          updated.pendingOrders = pendingOrders.length;
          updated.processingOrders = processingOrders.length;
          updated.recentOrders = JSON.stringify(recentOrders);
          updated.recentSignups = JSON.stringify(recentSignups);
        })
      );
    } else {
      await DataStore.save(
        new RealTimeStats({
          pendingOrders: pendingOrders.length,
          processingOrders: processingOrders.length,
          recentOrders: JSON.stringify(recentOrders),
          recentSignups: JSON.stringify(recentSignups),
          onlineUsers: 0,
          activeVendors: 0,
          systemHealth: JSON.stringify({
            status: 'healthy',
            responseTime: 150,
            errorRate: 0.01,
            uptime: 99.9,
          }),
        })
      );
    }
  }

  /**
   * Update real-time counters based on events
   */
  private static async updateRealTimeCounters(
    event: Omit<AnalyticsEvent, 'id' | 'timestamp'>
  ): Promise<void> {
    const stats = await DataStore.query(RealTimeStats);
    const currentStats = stats[0];

    if (currentStats) {
      switch (event.type) {
        case 'user_action':
      break;
          if (event.action === 'login') {
            await DataStore.save(
              RealTimeStats.copyOf(currentStats, (updated) => {
                updated.onlineUsers = (updated.onlineUsers || 0) + 1;
              })
            );
          }
          break;
        case 'purchase':
      break;
          // This would be handled by order creation
          break;
        default:
          // Generic event tracking
          break;
      }
    }
  }

  /**
   * Get analytics events with filtering
   */
  static async getAnalyticsEvents(
    filters: {
      type?: AnalyticsEvent['type'];
      userId?: string;
      productId?: string;
      vendorId?: string;
      startDate?: Date;
      endDate?: Date;
    },
    limitCount: number = 100
  ): Promise<AnalyticsEvent[]> {
    const { type, userId, productId, vendorId, startDate, endDate } = filters;

    return DataStore.query(AnalyticsEvent, (c) => {
      let criteria = c;
      if (type) {
        criteria = criteria.type('eq', type);
      }
      if (userId) {
        criteria = criteria.userId('eq', userId);
      }
      if (productId) {
        criteria = criteria.productId('eq', productId);
      }
      if (vendorId) {
        criteria = criteria.vendorId('eq', vendorId);
      }
      if (startDate) {
        criteria = criteria.timestamp('ge', startDate.toISOString());
      }
      if (endDate) {
        criteria = criteria.timestamp('le', endDate.toISOString());
      }
      return criteria.sort((s) => s.timestamp('DESCENDING')).limit(limitCount);
    });
  }

  /**
   * Track page view
   */
  static async trackPageView(
    userId: string | undefined,
    sessionId: string,
    page: string,
    metadata?: Record<string, any>
  ): Promise<void> {
    await this.trackEvent({
      type: 'page_view',
      userId,
      sessionId,
      action: 'view',
      label: page,
      metadata,
    });
  }

  /**
   * Track product view
   */
  static async trackProductView(
    userId: string | undefined,
    sessionId: string,
    productId: string,
    vendorId: string,
    category?: string
  ): Promise<void> {
    await this.trackEvent({
      type: 'product_view',
      userId,
      sessionId,
      productId,
      vendorId,
      category,
      action: 'view',
      label: 'product_detail',
    });
  }

  /**
   * Track add to cart
   */
  static async trackAddToCart(
    userId: string | undefined,
    sessionId: string,
    productId: string,
    vendorId: string,
    quantity: number,
    value: number
  ): Promise<void> {
    await this.trackEvent({
      type: 'add_to_cart',
      userId,
      sessionId,
      productId,
      vendorId,
      action: 'add_to_cart',
      value,
      metadata: { quantity },
    });
  }

  /**
   * Track purchase
   */
  static async trackPurchase(
    userId: string,
    sessionId: string,
    orderId: string,
    vendorId: string,
    value: number,
    items: Array<{ productId: string; quantity: number; price: number }>
  ): Promise<void> {
    await this.trackEvent({
      type: 'purchase',
      userId,
      sessionId,
      orderId,
      vendorId,
      action: 'purchase',
      value,
      metadata: { items },
    });
  }

  /**
   * Track search
   */
  static async trackSearch(
    userId: string | undefined,
    sessionId: string,
    searchTerm: string,
    resultsCount: number,
    filters?: Record<string, any>
  ): Promise<void> {
    await this.trackEvent({
      type: 'search',
      userId,
      sessionId,
      action: 'search',
      label: searchTerm,
      value: resultsCount,
      metadata: { filters },
    });
  }
}