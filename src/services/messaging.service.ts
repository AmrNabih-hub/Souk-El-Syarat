// AWS DataStore removed - using Appwrite database
// import { DataStore } from 'aws-amplify';
import { Message, Conversation } from '@/models'; // Assuming models are generated by Amplify

import { NotificationService } from './notification.service';

export type MessageType = 'text' | 'image' | 'file' | 'order_update' | 'system';
export type ConversationStatus = 'active' | 'closed' | 'archived';
export type ParticipantRole = 'customer' | 'vendor' | 'admin' | 'support';

export interface CreateConversationData {
  type: Conversation['type'];
  title?: string;
  participants: Array<{
    userId: string;
    userName: string;
    role: ParticipantRole;
  }>;
  orderId?: string;
  productId?: string;
  vendorId?: string;
  priority?: Conversation['priority'];
  tags?: string[];
  initialMessage?: {
    content: string;
    type: MessageType;
    metadata?: Record<string, any>;
  };
}

export interface SendMessageData {
  conversationId: string;
  senderId: string;
  senderName: string;
  senderRole: ParticipantRole;
  type: MessageType;
  content: string;
  metadata?: Record<string, any>;
  attachments?: Array<{
    name: string;
    url: string;
    type: string;
    size: number;
  }>;
  replyTo?: string;
}

export class MessagingService {
  /**
   * Create a new conversation
   */
  static async createConversation(data: CreateConversationData): Promise<string> {
    const newConversation = new Conversation({
      type: data.type,
      title: data.title,
      participants: JSON.stringify(data.participants),
      status: 'active',
      unreadCount: JSON.stringify({}),
      orderId: data.orderId,
      productId: data.productId,
      vendorId: data.vendorId,
      priority: data.priority || 'medium',
      tags: data.tags || [],
      metadata: JSON.stringify({}),
    });

    const savedConversation = await DataStore.save(newConversation);

    if (data.initialMessage) {
      const newMessage = new Message({
        conversationId: savedConversation.id,
        senderId: data.participants[0].userId,
        senderName: data.participants[0].userName,
        senderRole: data.participants[0].role,
        type: data.initialMessage.type,
        content: data.initialMessage.content,
        metadata: JSON.stringify(data.initialMessage.metadata),
        readBy: JSON.stringify([{
          userId: data.participants[0].userId,
          readAt: new Date().toISOString(),
        }]),
        edited: false,
      });
      await DataStore.save(newMessage);
    }

    return savedConversation.id;
  }

  /**
   * Send a message
   */
  static async sendMessage(data: SendMessageData): Promise<string> {
    const newMessage = new Message({
      conversationId: data.conversationId,
      senderId: data.senderId,
      senderName: data.senderName,
      senderRole: data.senderRole,
      type: data.type,
      content: data.content,
      metadata: JSON.stringify(data.metadata),
      attachments: JSON.stringify(data.attachments),
      readBy: JSON.stringify([{
        userId: data.senderId,
        readAt: new Date().toISOString(),
      }]),
      replyTo: data.replyTo,
      edited: false,
    });

    const savedMessage = await DataStore.save(newMessage);

    const conversation = await DataStore.query(Conversation, data.conversationId);

    if (conversation) {
      await DataStore.save(
        Conversation.copyOf(conversation, (updated) => {
          updated.lastMessage = JSON.stringify({
            content: data.content,
            senderId: data.senderId,
            senderName: data.senderName,
            timestamp: new Date().toISOString(),
            type: data.type,
          });
        })
      );
    }

    return savedMessage.id;
  }

  /**
   * Mark messages as read
   */
  static async markMessagesAsRead(conversationId: string, userId: string): Promise<void> {
    const messages = await DataStore.query(Message, (c) =>
      c.conversationId('eq', conversationId)
    );

    for (const message of messages) {
      const readBy = JSON.parse(message.readBy || '[]');
      if (!readBy.some((r: any) => r.userId === userId)) {
        await DataStore.save(
          Message.copyOf(message, (updated) => {
            updated.readBy = JSON.stringify([
              ...readBy,
              {
                userId,
                readAt: new Date().toISOString(),
              },
            ]);
          })
        );
      }
    }
  }

  /**
   * Subscribe to user conversations with real-time updates
   */
  static subscribeToUserConversations(
    userId: string,
    callback: (conversations: Conversation[]) => void,
    limitCount: number = 50
  ): () => void {
    const subscription = DataStore.observeQuery(Conversation, (c) =>
      c.participants('contains', userId)
    ).subscribe(({ items }) => {
      callback(items);
    });

    return () => subscription.unsubscribe();
  }

  /**
   * Subscribe to conversation messages with real-time updates
   */
  static subscribeToConversationMessages(
    conversationId: string,
    callback: (messages: Message[]) => void,
    limitCount: number = 100
  ): () => void {
    const subscription = DataStore.observeQuery(Message, (c) =>
      c.conversationId('eq', conversationId).sort((s) => s.createdAt('ASCENDING')).limit(limitCount)
    ).subscribe(({ items }) => {
      callback(items);
    });

    return () => subscription.unsubscribe();
  }

  /**
   * Get conversation by ID
   */
  static async getConversation(conversationId: string): Promise<Conversation | null> {
    return DataStore.query(Conversation, conversationId);
  }

  /**
   * Find or create conversation between users
   */
  static async findOrCreateConversation(
    participants: Array<{
      userId: string;
      userName: string;
      role: ParticipantRole;
    }>,
    type: Conversation['type'],
    orderId?: string,
    productId?: string
  ): Promise<string> {
    const participantIds = participants.map((p) => p.userId).sort();

    const conversations = await DataStore.query(Conversation, (c) =>
      c.type('eq', type)
    );

    for (const conversation of conversations) {
      const existingParticipantIds = JSON.parse(conversation.participants).map((p: any) => p.userId).sort();
      if (JSON.stringify(participantIds) === JSON.stringify(existingParticipantIds)) {
        if (
          (orderId && conversation.orderId === orderId) ||
          (productId && conversation.productId === productId) ||
          (!orderId && !productId)
        ) {
          return conversation.id;
        }
      }
    }

    return this.createConversation({
      type,
      participants,
      orderId,
      productId,
      vendorId: participants.find((p) => p.role === 'vendor')?.userId,
    });
  }

  /**
   * Close conversation
   */
  static async closeConversation(conversationId: string, closedBy: string): Promise<void> {
    const conversation = await DataStore.query(Conversation, conversationId);

    if (conversation) {
      await DataStore.save(
        Conversation.copyOf(conversation, (updated) => {
          updated.status = 'closed';
          updated.metadata = JSON.stringify({
            closedBy,
            closedAt: new Date().toISOString(),
          });
        })
      );
    }
  }

  /**
   * Archive conversation
   */
  static async archiveConversation(conversationId: string): Promise<void> {
    const conversation = await DataStore.query(Conversation, conversationId);

    if (conversation) {
      await DataStore.save(
        Conversation.copyOf(conversation, (updated) => {
          updated.status = 'archived';
        })
      );
    }
  }

  /**
   * Add participant to conversation
   */
  static async addParticipant(
    conversationId: string,
    participant: {
      userId: string;
      userName: string;
      role: ParticipantRole;
    }
  ): Promise<void> {
    const conversation = await DataStore.query(Conversation, conversationId);

    if (conversation) {
      const participants = JSON.parse(conversation.participants);
      participants.push(participant);

      await DataStore.save(
        Conversation.copyOf(conversation, (updated) => {
          updated.participants = JSON.stringify(participants);
        })
      );
    }
  }

  /**
   * Remove participant from conversation
   */
  static async removeParticipant(conversationId: string, userId: string): Promise<void> {
    const conversation = await DataStore.query(Conversation, conversationId);

    if (conversation) {
      const participants = JSON.parse(conversation.participants).filter(
        (p: any) => p.userId !== userId
      );

      await DataStore.save(
        Conversation.copyOf(conversation, (updated) => {
          updated.participants = JSON.stringify(participants);
        })
      );
    }
  }

  /**
   * Edit message
   */
  static async editMessage(messageId: string, newContent: string): Promise<void> {
    const message = await DataStore.query(Message, messageId);

    if (message) {
      await DataStore.save(
        Message.copyOf(message, (updated) => {
          updated.content = newContent;
          updated.edited = true;
        })
      );
    }
  }

  /**
   * Get unread conversations count
   */
  static subscribeToUnreadConversationsCount(
    userId: string,
    callback: (count: number) => void
  ): () => void {
    const subscription = DataStore.observeQuery(Conversation, (c) =>
      c.participants('contains', userId)
    ).subscribe(({ items }) => {
      let unreadCount = 0;
      for (const item of items) {
        const unread = JSON.parse(item.unreadCount || '{}');
        if (unread[userId] > 0) {
          unreadCount++;
        }
      }
      callback(unreadCount);
    });

    return () => subscription.unsubscribe();
  }
}